# coding: utf-8

"""
    Intercom API

    The intercom API reference.  # noqa: E501

    OpenAPI spec version: 2.11
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from ..api_client import ApiClient


class TicketsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def attach_tag_to_ticket(self, ticket_id, **kwargs):  # noqa: E501
        """Add tag to a ticket  # noqa: E501

        You can tag a specific ticket. This will return a tag object for the tag that was added to the ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_tag_to_ticket(ticket_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: ticket_id (required)
        :param TicketIdTagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.attach_tag_to_ticket_with_http_info(ticket_id, **kwargs)  # noqa: E501
        else:
            (data) = self.attach_tag_to_ticket_with_http_info(ticket_id, **kwargs)  # noqa: E501
            return data

    def attach_tag_to_ticket_with_http_info(self, ticket_id, **kwargs):  # noqa: E501
        """Add tag to a ticket  # noqa: E501

        You can tag a specific ticket. This will return a tag object for the tag that was added to the ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_tag_to_ticket_with_http_info(ticket_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: ticket_id (required)
        :param TicketIdTagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ticket_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_tag_to_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ticket_id' is set
        if ('ticket_id' not in params or
                params['ticket_id'] is None):
            raise ValueError("Missing the required parameter `ticket_id` when calling `attach_tag_to_ticket`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ticket_id' in params:
            path_params['ticket_id'] = params['ticket_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/tickets/{ticket_id}/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ticket(self, **kwargs):  # noqa: E501
        """Create a ticket  # noqa: E501

        You can create a new ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ticket(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateTicketRequest body:
        :param IntercomVersion intercom_version:
        :return: Ticket
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_ticket_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_ticket_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_ticket_with_http_info(self, **kwargs):  # noqa: E501
        """Create a ticket  # noqa: E501

        You can create a new ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ticket_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateTicketRequest body:
        :param IntercomVersion intercom_version:
        :return: Ticket
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ticket" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/tickets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ticket',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_tag_from_ticket(self, ticket_id, tag_id, **kwargs):  # noqa: E501
        """Remove tag from a ticket  # noqa: E501

        You can remove tag from a specific ticket. This will return a tag object for the tag that was removed from the ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_tag_from_ticket(ticket_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: ticket_id (required)
        :param str tag_id: The unique identifier for the tag which is given by Intercom (required)
        :param TagsTagIdBody1 body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_tag_from_ticket_with_http_info(ticket_id, tag_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_tag_from_ticket_with_http_info(ticket_id, tag_id, **kwargs)  # noqa: E501
            return data

    def detach_tag_from_ticket_with_http_info(self, ticket_id, tag_id, **kwargs):  # noqa: E501
        """Remove tag from a ticket  # noqa: E501

        You can remove tag from a specific ticket. This will return a tag object for the tag that was removed from the ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_tag_from_ticket_with_http_info(ticket_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: ticket_id (required)
        :param str tag_id: The unique identifier for the tag which is given by Intercom (required)
        :param TagsTagIdBody1 body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ticket_id', 'tag_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_tag_from_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ticket_id' is set
        if ('ticket_id' not in params or
                params['ticket_id'] is None):
            raise ValueError("Missing the required parameter `ticket_id` when calling `detach_tag_from_ticket`")  # noqa: E501
        # verify the required parameter 'tag_id' is set
        if ('tag_id' not in params or
                params['tag_id'] is None):
            raise ValueError("Missing the required parameter `tag_id` when calling `detach_tag_from_ticket`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ticket_id' in params:
            path_params['ticket_id'] = params['ticket_id']  # noqa: E501
        if 'tag_id' in params:
            path_params['tag_id'] = params['tag_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/tickets/{ticket_id}/tags/{tag_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ticket(self, ticket_id, **kwargs):  # noqa: E501
        """Retrieve a ticket  # noqa: E501

        You can fetch the details of a single ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ticket(ticket_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: The unique identifier for the ticket which is given by Intercom. (required)
        :param IntercomVersion intercom_version:
        :return: Ticket
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ticket_with_http_info(ticket_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ticket_with_http_info(ticket_id, **kwargs)  # noqa: E501
            return data

    def get_ticket_with_http_info(self, ticket_id, **kwargs):  # noqa: E501
        """Retrieve a ticket  # noqa: E501

        You can fetch the details of a single ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ticket_with_http_info(ticket_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: The unique identifier for the ticket which is given by Intercom. (required)
        :param IntercomVersion intercom_version:
        :return: Ticket
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ticket_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ticket_id' is set
        if ('ticket_id' not in params or
                params['ticket_id'] is None):
            raise ValueError("Missing the required parameter `ticket_id` when calling `get_ticket`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ticket_id' in params:
            path_params['ticket_id'] = params['ticket_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/tickets/{ticket_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ticket',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reply_ticket(self, ticket_id, **kwargs):  # noqa: E501
        """Reply to a ticket  # noqa: E501

        You can reply to a ticket with a message from an admin or on behalf of a contact, or with a note for admins.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reply_ticket(ticket_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: (required)
        :param TicketIdReplyBody body:
        :param IntercomVersion intercom_version:
        :return: TicketReply
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reply_ticket_with_http_info(ticket_id, **kwargs)  # noqa: E501
        else:
            (data) = self.reply_ticket_with_http_info(ticket_id, **kwargs)  # noqa: E501
            return data

    def reply_ticket_with_http_info(self, ticket_id, **kwargs):  # noqa: E501
        """Reply to a ticket  # noqa: E501

        You can reply to a ticket with a message from an admin or on behalf of a contact, or with a note for admins.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reply_ticket_with_http_info(ticket_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: (required)
        :param TicketIdReplyBody body:
        :param IntercomVersion intercom_version:
        :return: TicketReply
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ticket_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reply_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ticket_id' is set
        if ('ticket_id' not in params or
                params['ticket_id'] is None):
            raise ValueError("Missing the required parameter `ticket_id` when calling `reply_ticket`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ticket_id' in params:
            path_params['ticket_id'] = params['ticket_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/tickets/{ticket_id}/reply', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TicketReply',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_tickets(self, **kwargs):  # noqa: E501
        """Search tickets  # noqa: E501

        You can search for multiple tickets by the value of their attributes in order to fetch exactly which ones you want.  To search for tickets, you send a `POST` request to `https://api.intercom.io/tickets/search`.  This will accept a query object in the body which will define your filters. {% admonition type=\"warning\" name=\"Optimizing search queries\" %}   Search queries can be complex, so optimizing them can help the performance of your search.   Use the `AND` and `OR` operators to combine multiple filters to get the exact results you need and utilize   pagination to limit the number of results returned. The default is `20` results per page.   See the [pagination section](https://developers.intercom.com/docs/build-an-integration/learn-more/rest-apis/pagination/#example-search-conversations-request) for more details on how to use the `starting_after` param. {% /admonition %}  ### Nesting & Limitations  You can nest these filters in order to get even more granular insights that pinpoint exactly what you need. Example: (1 OR 2) AND (3 OR 4). There are some limitations to the amount of multiples there can be: - There's a limit of max 2 nested filters - There's a limit of max 15 filters for each AND or OR group  ### Accepted Fields  Most keys listed as part of the Ticket model are searchable, whether writeable or not. The value you search for has to match the accepted type, otherwise the query will fail (ie. as `created_at` accepts a date, the `value` cannot be a string such as `\"foobar\"`).  | Field                                     | Type                                                                                     | | :---------------------------------------- | :--------------------------------------------------------------------------------------- | | id                                        | String                                                                                   | | created_at                                | Date (UNIX timestamp)                                                                    | | updated_at                                | Date (UNIX timestamp)                                                                    | | _default_title_                           | String                                                                                   | | _default_description_                     | String                                                                                   | | category                                  | String                                                                                   | | ticket_type_id                            | String                                                                                   | | contact_ids                               | String                                                                                   | | teammate_ids                              | String                                                                                   | | admin_assignee_id                         | String                                                                                   | | team_assignee_id                          | String                                                                                   | | open                                      | Boolean                                                                                  | | state                                     | String                                                                                   | | snoozed_until                             | Date (UNIX timestamp)                                                                    | | ticket_attribute.{id}                     | String or Boolean or Date (UNIX timestamp) or Float or Integer                           |  ### Accepted Operators  {% admonition type=\"info\" name=\"Searching based on `created_at`\" %}   You may use the `<=` or `>=` operators to search by `created_at`. {% /admonition %}  The table below shows the operators you can use to define how you want to search for the value.  The operator should be put in as a string (`\"=\"`). The operator has to be compatible with the field's type  (eg. you cannot search with `>` for a given string value as it's only compatible for integer's and dates).  | Operator | Valid Types                    | Description                                                  | | :------- | :----------------------------- | :----------------------------------------------------------- | | =        | All                            | Equals                                                       | | !=       | All                            | Doesn't Equal                                                | | IN       | All                            | In  Shortcut for `OR` queries  Values most be in Array       | | NIN      | All                            | Not In  Shortcut for `OR !` queries  Values must be in Array | | >        | Integer  Date (UNIX Timestamp) | Greater (or equal) than                                      | | <       | Integer  Date (UNIX Timestamp) | Lower (or equal) than                                        | | ~        | String                         | Contains                                                     | | !~       | String                         | Doesn't Contain                                              | | ^        | String                         | Starts With                                                  | | $        | String                         | Ends With                                                    |   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_tickets(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SearchRequest body:
        :param IntercomVersion intercom_version:
        :return: TicketList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_tickets_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_tickets_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_tickets_with_http_info(self, **kwargs):  # noqa: E501
        """Search tickets  # noqa: E501

        You can search for multiple tickets by the value of their attributes in order to fetch exactly which ones you want.  To search for tickets, you send a `POST` request to `https://api.intercom.io/tickets/search`.  This will accept a query object in the body which will define your filters. {% admonition type=\"warning\" name=\"Optimizing search queries\" %}   Search queries can be complex, so optimizing them can help the performance of your search.   Use the `AND` and `OR` operators to combine multiple filters to get the exact results you need and utilize   pagination to limit the number of results returned. The default is `20` results per page.   See the [pagination section](https://developers.intercom.com/docs/build-an-integration/learn-more/rest-apis/pagination/#example-search-conversations-request) for more details on how to use the `starting_after` param. {% /admonition %}  ### Nesting & Limitations  You can nest these filters in order to get even more granular insights that pinpoint exactly what you need. Example: (1 OR 2) AND (3 OR 4). There are some limitations to the amount of multiples there can be: - There's a limit of max 2 nested filters - There's a limit of max 15 filters for each AND or OR group  ### Accepted Fields  Most keys listed as part of the Ticket model are searchable, whether writeable or not. The value you search for has to match the accepted type, otherwise the query will fail (ie. as `created_at` accepts a date, the `value` cannot be a string such as `\"foobar\"`).  | Field                                     | Type                                                                                     | | :---------------------------------------- | :--------------------------------------------------------------------------------------- | | id                                        | String                                                                                   | | created_at                                | Date (UNIX timestamp)                                                                    | | updated_at                                | Date (UNIX timestamp)                                                                    | | _default_title_                           | String                                                                                   | | _default_description_                     | String                                                                                   | | category                                  | String                                                                                   | | ticket_type_id                            | String                                                                                   | | contact_ids                               | String                                                                                   | | teammate_ids                              | String                                                                                   | | admin_assignee_id                         | String                                                                                   | | team_assignee_id                          | String                                                                                   | | open                                      | Boolean                                                                                  | | state                                     | String                                                                                   | | snoozed_until                             | Date (UNIX timestamp)                                                                    | | ticket_attribute.{id}                     | String or Boolean or Date (UNIX timestamp) or Float or Integer                           |  ### Accepted Operators  {% admonition type=\"info\" name=\"Searching based on `created_at`\" %}   You may use the `<=` or `>=` operators to search by `created_at`. {% /admonition %}  The table below shows the operators you can use to define how you want to search for the value.  The operator should be put in as a string (`\"=\"`). The operator has to be compatible with the field's type  (eg. you cannot search with `>` for a given string value as it's only compatible for integer's and dates).  | Operator | Valid Types                    | Description                                                  | | :------- | :----------------------------- | :----------------------------------------------------------- | | =        | All                            | Equals                                                       | | !=       | All                            | Doesn't Equal                                                | | IN       | All                            | In  Shortcut for `OR` queries  Values most be in Array       | | NIN      | All                            | Not In  Shortcut for `OR !` queries  Values must be in Array | | >        | Integer  Date (UNIX Timestamp) | Greater (or equal) than                                      | | <       | Integer  Date (UNIX Timestamp) | Lower (or equal) than                                        | | ~        | String                         | Contains                                                     | | !~       | String                         | Doesn't Contain                                              | | ^        | String                         | Starts With                                                  | | $        | String                         | Ends With                                                    |   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_tickets_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SearchRequest body:
        :param IntercomVersion intercom_version:
        :return: TicketList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_tickets" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/tickets/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TicketList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ticket(self, ticket_id, **kwargs):  # noqa: E501
        """Update a ticket  # noqa: E501

        You can update a ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ticket(ticket_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: The unique identifier for the ticket which is given by Intercom (required)
        :param UpdateTicketRequest body:
        :param IntercomVersion intercom_version:
        :return: Ticket
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ticket_with_http_info(ticket_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ticket_with_http_info(ticket_id, **kwargs)  # noqa: E501
            return data

    def update_ticket_with_http_info(self, ticket_id, **kwargs):  # noqa: E501
        """Update a ticket  # noqa: E501

        You can update a ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ticket_with_http_info(ticket_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: The unique identifier for the ticket which is given by Intercom (required)
        :param UpdateTicketRequest body:
        :param IntercomVersion intercom_version:
        :return: Ticket
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ticket_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ticket_id' is set
        if ('ticket_id' not in params or
                params['ticket_id'] is None):
            raise ValueError("Missing the required parameter `ticket_id` when calling `update_ticket`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ticket_id' in params:
            path_params['ticket_id'] = params['ticket_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/tickets/{ticket_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ticket',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
