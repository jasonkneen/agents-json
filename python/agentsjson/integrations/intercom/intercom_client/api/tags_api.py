# coding: utf-8

"""
    Intercom API

    The intercom API reference.  # noqa: E501

    OpenAPI spec version: 2.11
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from ..api_client import ApiClient


class TagsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def attach_tag_to_contact(self, contact_id, **kwargs):  # noqa: E501
        """Add tag to a contact  # noqa: E501

        You can tag a specific contact. This will return a tag object for the tag that was added to the contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_tag_to_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param ContactIdTagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.attach_tag_to_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.attach_tag_to_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def attach_tag_to_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Add tag to a contact  # noqa: E501

        You can tag a specific contact. This will return a tag object for the tag that was added to the contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_tag_to_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param ContactIdTagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_tag_to_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `attach_tag_to_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def attach_tag_to_conversation(self, conversation_id, **kwargs):  # noqa: E501
        """Add tag to a conversation  # noqa: E501

        You can tag a specific conversation. This will return a tag object for the tag that was added to the conversation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_tag_to_conversation(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: conversation_id (required)
        :param ConversationIdTagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.attach_tag_to_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.attach_tag_to_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
            return data

    def attach_tag_to_conversation_with_http_info(self, conversation_id, **kwargs):  # noqa: E501
        """Add tag to a conversation  # noqa: E501

        You can tag a specific conversation. This will return a tag object for the tag that was added to the conversation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_tag_to_conversation_with_http_info(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: conversation_id (required)
        :param ConversationIdTagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_tag_to_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_id' is set
        if ('conversation_id' not in params or
                params['conversation_id'] is None):
            raise ValueError("Missing the required parameter `conversation_id` when calling `attach_tag_to_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'conversation_id' in params:
            path_params['conversation_id'] = params['conversation_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/{conversation_id}/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def attach_tag_to_ticket(self, ticket_id, **kwargs):  # noqa: E501
        """Add tag to a ticket  # noqa: E501

        You can tag a specific ticket. This will return a tag object for the tag that was added to the ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_tag_to_ticket(ticket_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: ticket_id (required)
        :param TicketIdTagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.attach_tag_to_ticket_with_http_info(ticket_id, **kwargs)  # noqa: E501
        else:
            (data) = self.attach_tag_to_ticket_with_http_info(ticket_id, **kwargs)  # noqa: E501
            return data

    def attach_tag_to_ticket_with_http_info(self, ticket_id, **kwargs):  # noqa: E501
        """Add tag to a ticket  # noqa: E501

        You can tag a specific ticket. This will return a tag object for the tag that was added to the ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_tag_to_ticket_with_http_info(ticket_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: ticket_id (required)
        :param TicketIdTagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ticket_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_tag_to_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ticket_id' is set
        if ('ticket_id' not in params or
                params['ticket_id'] is None):
            raise ValueError("Missing the required parameter `ticket_id` when calling `attach_tag_to_ticket`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ticket_id' in params:
            path_params['ticket_id'] = params['ticket_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/tickets/{ticket_id}/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_tag(self, **kwargs):  # noqa: E501
        """Create or update a tag, Tag or untag companies, Tag contacts  # noqa: E501

        You can use this endpoint to perform the following operations:    **1. Create a new tag:** You can create a new tag by passing in the tag name as specified in \"Create or Update Tag Request Payload\" described below.    **2. Update an existing tag:** You can update an existing tag by passing the id of the tag as specified in \"Create or Update Tag Request Payload\" described below.    **3. Tag Companies:** You can tag single company or a list of companies. You can tag a company by passing in the tag name and the company details as specified in \"Tag Company Request Payload\" described below. Also, if the tag doesn't exist then a new one will be created automatically.    **4. Untag Companies:** You can untag a single company or a list of companies. You can untag a company by passing in the tag id and the company details as specified in \"Untag Company Request Payload\" described below.    **5. Tag Multiple Users:** You can tag a list of users. You can tag the users by passing in the tag name and the user details as specified in \"Tag Users Request Payload\" described below.  Each operation will return a tag object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tag(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_tag_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_tag_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_tag_with_http_info(self, **kwargs):  # noqa: E501
        """Create or update a tag, Tag or untag companies, Tag contacts  # noqa: E501

        You can use this endpoint to perform the following operations:    **1. Create a new tag:** You can create a new tag by passing in the tag name as specified in \"Create or Update Tag Request Payload\" described below.    **2. Update an existing tag:** You can update an existing tag by passing the id of the tag as specified in \"Create or Update Tag Request Payload\" described below.    **3. Tag Companies:** You can tag single company or a list of companies. You can tag a company by passing in the tag name and the company details as specified in \"Tag Company Request Payload\" described below. Also, if the tag doesn't exist then a new one will be created automatically.    **4. Untag Companies:** You can untag a single company or a list of companies. You can untag a company by passing in the tag id and the company details as specified in \"Untag Company Request Payload\" described below.    **5. Tag Multiple Users:** You can tag a list of users. You can tag the users by passing in the tag name and the user details as specified in \"Tag Users Request Payload\" described below.  Each operation will return a tag object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_tag_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param TagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_tag" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_tag(self, tag_id, **kwargs):  # noqa: E501
        """Delete tag  # noqa: E501

        You can delete the details of tags that are on the workspace by passing in the id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tag(tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tag_id: The unique identifier of a given tag (required)
        :param IntercomVersion intercom_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_tag_with_http_info(tag_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_tag_with_http_info(tag_id, **kwargs)  # noqa: E501
            return data

    def delete_tag_with_http_info(self, tag_id, **kwargs):  # noqa: E501
        """Delete tag  # noqa: E501

        You can delete the details of tags that are on the workspace by passing in the id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_tag_with_http_info(tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tag_id: The unique identifier of a given tag (required)
        :param IntercomVersion intercom_version:
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tag_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tag_id' is set
        if ('tag_id' not in params or
                params['tag_id'] is None):
            raise ValueError("Missing the required parameter `tag_id` when calling `delete_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tag_id' in params:
            path_params['tag_id'] = params['tag_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/tags/{tag_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_tag_from_contact(self, contact_id, tag_id, **kwargs):  # noqa: E501
        """Remove tag from a contact  # noqa: E501

        You can remove tag from a specific contact. This will return a tag object for the tag that was removed from the contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_tag_from_contact(contact_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param str tag_id: The unique identifier for the tag which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_tag_from_contact_with_http_info(contact_id, tag_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_tag_from_contact_with_http_info(contact_id, tag_id, **kwargs)  # noqa: E501
            return data

    def detach_tag_from_contact_with_http_info(self, contact_id, tag_id, **kwargs):  # noqa: E501
        """Remove tag from a contact  # noqa: E501

        You can remove tag from a specific contact. This will return a tag object for the tag that was removed from the contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_tag_from_contact_with_http_info(contact_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param str tag_id: The unique identifier for the tag which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'tag_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_tag_from_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `detach_tag_from_contact`")  # noqa: E501
        # verify the required parameter 'tag_id' is set
        if ('tag_id' not in params or
                params['tag_id'] is None):
            raise ValueError("Missing the required parameter `tag_id` when calling `detach_tag_from_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501
        if 'tag_id' in params:
            path_params['tag_id'] = params['tag_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/tags/{tag_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_tag_from_conversation(self, conversation_id, tag_id, **kwargs):  # noqa: E501
        """Remove tag from a conversation  # noqa: E501

        You can remove tag from a specific conversation. This will return a tag object for the tag that was removed from the conversation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_tag_from_conversation(conversation_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: conversation_id (required)
        :param str tag_id: id (required)
        :param TagsTagIdBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_tag_from_conversation_with_http_info(conversation_id, tag_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_tag_from_conversation_with_http_info(conversation_id, tag_id, **kwargs)  # noqa: E501
            return data

    def detach_tag_from_conversation_with_http_info(self, conversation_id, tag_id, **kwargs):  # noqa: E501
        """Remove tag from a conversation  # noqa: E501

        You can remove tag from a specific conversation. This will return a tag object for the tag that was removed from the conversation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_tag_from_conversation_with_http_info(conversation_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: conversation_id (required)
        :param str tag_id: id (required)
        :param TagsTagIdBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_id', 'tag_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_tag_from_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_id' is set
        if ('conversation_id' not in params or
                params['conversation_id'] is None):
            raise ValueError("Missing the required parameter `conversation_id` when calling `detach_tag_from_conversation`")  # noqa: E501
        # verify the required parameter 'tag_id' is set
        if ('tag_id' not in params or
                params['tag_id'] is None):
            raise ValueError("Missing the required parameter `tag_id` when calling `detach_tag_from_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'conversation_id' in params:
            path_params['conversation_id'] = params['conversation_id']  # noqa: E501
        if 'tag_id' in params:
            path_params['tag_id'] = params['tag_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/{conversation_id}/tags/{tag_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_tag_from_ticket(self, ticket_id, tag_id, **kwargs):  # noqa: E501
        """Remove tag from a ticket  # noqa: E501

        You can remove tag from a specific ticket. This will return a tag object for the tag that was removed from the ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_tag_from_ticket(ticket_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: ticket_id (required)
        :param str tag_id: The unique identifier for the tag which is given by Intercom (required)
        :param TagsTagIdBody1 body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_tag_from_ticket_with_http_info(ticket_id, tag_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_tag_from_ticket_with_http_info(ticket_id, tag_id, **kwargs)  # noqa: E501
            return data

    def detach_tag_from_ticket_with_http_info(self, ticket_id, tag_id, **kwargs):  # noqa: E501
        """Remove tag from a ticket  # noqa: E501

        You can remove tag from a specific ticket. This will return a tag object for the tag that was removed from the ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_tag_from_ticket_with_http_info(ticket_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ticket_id: ticket_id (required)
        :param str tag_id: The unique identifier for the tag which is given by Intercom (required)
        :param TagsTagIdBody1 body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ticket_id', 'tag_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_tag_from_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ticket_id' is set
        if ('ticket_id' not in params or
                params['ticket_id'] is None):
            raise ValueError("Missing the required parameter `ticket_id` when calling `detach_tag_from_ticket`")  # noqa: E501
        # verify the required parameter 'tag_id' is set
        if ('tag_id' not in params or
                params['tag_id'] is None):
            raise ValueError("Missing the required parameter `tag_id` when calling `detach_tag_from_ticket`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'ticket_id' in params:
            path_params['ticket_id'] = params['ticket_id']  # noqa: E501
        if 'tag_id' in params:
            path_params['tag_id'] = params['tag_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/tickets/{ticket_id}/tags/{tag_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def find_tag(self, tag_id, **kwargs):  # noqa: E501
        """Find a specific tag  # noqa: E501

        You can fetch the details of tags that are on the workspace by their id. This will return a tag object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_tag(tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tag_id: The unique identifier of a given tag (required)
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.find_tag_with_http_info(tag_id, **kwargs)  # noqa: E501
        else:
            (data) = self.find_tag_with_http_info(tag_id, **kwargs)  # noqa: E501
            return data

    def find_tag_with_http_info(self, tag_id, **kwargs):  # noqa: E501
        """Find a specific tag  # noqa: E501

        You can fetch the details of tags that are on the workspace by their id. This will return a tag object.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.find_tag_with_http_info(tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str tag_id: The unique identifier of a given tag (required)
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['tag_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_tag" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'tag_id' is set
        if ('tag_id' not in params or
                params['tag_id'] is None):
            raise ValueError("Missing the required parameter `tag_id` when calling `find_tag`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'tag_id' in params:
            path_params['tag_id'] = params['tag_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/tags/{tag_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_tags(self, **kwargs):  # noqa: E501
        """List all tags  # noqa: E501

        You can fetch a list of all tags for a given workspace.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_tags(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IntercomVersion intercom_version:
        :return: TagList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_tags_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_tags_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_tags_with_http_info(self, **kwargs):  # noqa: E501
        """List all tags  # noqa: E501

        You can fetch a list of all tags for a given workspace.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_tags_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IntercomVersion intercom_version:
        :return: TagList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_tags" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_tags_for_a_contact(self, contact_id, **kwargs):  # noqa: E501
        """List tags attached to a contact  # noqa: E501

        You can fetch a list of all tags that are attached to a specific contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_tags_for_a_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: TagList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_tags_for_a_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_tags_for_a_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def list_tags_for_a_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """List tags attached to a contact  # noqa: E501

        You can fetch a list of all tags that are attached to a specific contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_tags_for_a_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: TagList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_tags_for_a_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `list_tags_for_a_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
