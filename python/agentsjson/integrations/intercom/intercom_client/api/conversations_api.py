# coding: utf-8

"""
    Intercom API

    The intercom API reference.  # noqa: E501

    OpenAPI spec version: 2.11
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from ..api_client import ApiClient


class ConversationsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def attach_contact_to_conversation(self, conversation_id, **kwargs):  # noqa: E501
        """Attach a contact to a conversation  # noqa: E501

        You can add participants who are contacts to a conversation, on behalf of either another contact or an admin.  {% admonition type=\"attention\" name=\"Contacts without an email\" %} If you add a contact via the email parameter and there is no user/lead found on that workspace with he given email, then we will create a new contact with `role` set to `lead`. {% /admonition %}    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_contact_to_conversation(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The identifier for the conversation as given by Intercom. (required)
        :param AttachContactToConversationRequest body:
        :param IntercomVersion intercom_version:
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.attach_contact_to_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.attach_contact_to_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
            return data

    def attach_contact_to_conversation_with_http_info(self, conversation_id, **kwargs):  # noqa: E501
        """Attach a contact to a conversation  # noqa: E501

        You can add participants who are contacts to a conversation, on behalf of either another contact or an admin.  {% admonition type=\"attention\" name=\"Contacts without an email\" %} If you add a contact via the email parameter and there is no user/lead found on that workspace with he given email, then we will create a new contact with `role` set to `lead`. {% /admonition %}    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_contact_to_conversation_with_http_info(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The identifier for the conversation as given by Intercom. (required)
        :param AttachContactToConversationRequest body:
        :param IntercomVersion intercom_version:
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_contact_to_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_id' is set
        if ('conversation_id' not in params or
                params['conversation_id'] is None):
            raise ValueError("Missing the required parameter `conversation_id` when calling `attach_contact_to_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'conversation_id' in params:
            path_params['conversation_id'] = params['conversation_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/{conversation_id}/customers', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Conversation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def attach_tag_to_conversation(self, conversation_id, **kwargs):  # noqa: E501
        """Add tag to a conversation  # noqa: E501

        You can tag a specific conversation. This will return a tag object for the tag that was added to the conversation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_tag_to_conversation(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: conversation_id (required)
        :param ConversationIdTagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.attach_tag_to_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.attach_tag_to_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
            return data

    def attach_tag_to_conversation_with_http_info(self, conversation_id, **kwargs):  # noqa: E501
        """Add tag to a conversation  # noqa: E501

        You can tag a specific conversation. This will return a tag object for the tag that was added to the conversation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_tag_to_conversation_with_http_info(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: conversation_id (required)
        :param ConversationIdTagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_tag_to_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_id' is set
        if ('conversation_id' not in params or
                params['conversation_id'] is None):
            raise ValueError("Missing the required parameter `conversation_id` when calling `attach_tag_to_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'conversation_id' in params:
            path_params['conversation_id'] = params['conversation_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/{conversation_id}/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def auto_assign_conversation(self, conversation_id, **kwargs):  # noqa: E501
        """Run Assignment Rules on a conversation  # noqa: E501

        You can let a conversation be automatically assigned following assignment rules. {% admonition type=\"attention\" name=\"When using workflows\" %} It is not possible to use this endpoint with Workflows. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auto_assign_conversation(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The identifier for the conversation as given by Intercom. (required)
        :param IntercomVersion intercom_version:
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.auto_assign_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.auto_assign_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
            return data

    def auto_assign_conversation_with_http_info(self, conversation_id, **kwargs):  # noqa: E501
        """Run Assignment Rules on a conversation  # noqa: E501

        You can let a conversation be automatically assigned following assignment rules. {% admonition type=\"attention\" name=\"When using workflows\" %} It is not possible to use this endpoint with Workflows. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.auto_assign_conversation_with_http_info(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The identifier for the conversation as given by Intercom. (required)
        :param IntercomVersion intercom_version:
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method auto_assign_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_id' is set
        if ('conversation_id' not in params or
                params['conversation_id'] is None):
            raise ValueError("Missing the required parameter `conversation_id` when calling `auto_assign_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'conversation_id' in params:
            path_params['conversation_id'] = params['conversation_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/{conversation_id}/run_assignment_rules', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Conversation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def convert_conversation_to_ticket(self, conversation_id, **kwargs):  # noqa: E501
        """Convert a conversation to a ticket  # noqa: E501

        You can convert a conversation to a ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.convert_conversation_to_ticket(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The id of the conversation to target (required)
        :param ConvertConversationToTicketRequest body:
        :param IntercomVersion intercom_version:
        :return: Ticket
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.convert_conversation_to_ticket_with_http_info(conversation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.convert_conversation_to_ticket_with_http_info(conversation_id, **kwargs)  # noqa: E501
            return data

    def convert_conversation_to_ticket_with_http_info(self, conversation_id, **kwargs):  # noqa: E501
        """Convert a conversation to a ticket  # noqa: E501

        You can convert a conversation to a ticket.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.convert_conversation_to_ticket_with_http_info(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The id of the conversation to target (required)
        :param ConvertConversationToTicketRequest body:
        :param IntercomVersion intercom_version:
        :return: Ticket
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method convert_conversation_to_ticket" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_id' is set
        if ('conversation_id' not in params or
                params['conversation_id'] is None):
            raise ValueError("Missing the required parameter `conversation_id` when calling `convert_conversation_to_ticket`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'conversation_id' in params:
            path_params['conversation_id'] = params['conversation_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/{conversation_id}/convert', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ticket',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_conversation(self, **kwargs):  # noqa: E501
        """Creates a conversation  # noqa: E501

        You can create a conversation that has been initiated by a contact (ie. user or lead). The conversation can be an in-app message only.  {% admonition type=\"info\" name=\"Sending for visitors\" %} You can also send a message from a visitor by specifying their `user_id` or `id` value in the `from` field, along with a `type` field value of `contact`. This visitor will be automatically converted to a contact with a lead role once the conversation is created. {% /admonition %}  This will return the Message model that has been created.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_conversation(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateConversationRequest body:
        :param IntercomVersion intercom_version:
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_conversation_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_conversation_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_conversation_with_http_info(self, **kwargs):  # noqa: E501
        """Creates a conversation  # noqa: E501

        You can create a conversation that has been initiated by a contact (ie. user or lead). The conversation can be an in-app message only.  {% admonition type=\"info\" name=\"Sending for visitors\" %} You can also send a message from a visitor by specifying their `user_id` or `id` value in the `from` field, along with a `type` field value of `contact`. This visitor will be automatically converted to a contact with a lead role once the conversation is created. {% /admonition %}  This will return the Message model that has been created.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_conversation_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateConversationRequest body:
        :param IntercomVersion intercom_version:
        :return: Message
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_conversation" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Message',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_contact_from_conversation(self, conversation_id, contact_id, **kwargs):  # noqa: E501
        """Detach a contact from a group conversation  # noqa: E501

        You can add participants who are contacts to a conversation, on behalf of either another contact or an admin.  {% admonition type=\"attention\" name=\"Contacts without an email\" %} If you add a contact via the email parameter and there is no user/lead found on that workspace with he given email, then we will create a new contact with `role` set to `lead`. {% /admonition %}    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_contact_from_conversation(conversation_id, contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The identifier for the conversation as given by Intercom. (required)
        :param str contact_id: The identifier for the contact as given by Intercom. (required)
        :param DetachContactFromConversationRequest body:
        :param IntercomVersion intercom_version:
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_contact_from_conversation_with_http_info(conversation_id, contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_contact_from_conversation_with_http_info(conversation_id, contact_id, **kwargs)  # noqa: E501
            return data

    def detach_contact_from_conversation_with_http_info(self, conversation_id, contact_id, **kwargs):  # noqa: E501
        """Detach a contact from a group conversation  # noqa: E501

        You can add participants who are contacts to a conversation, on behalf of either another contact or an admin.  {% admonition type=\"attention\" name=\"Contacts without an email\" %} If you add a contact via the email parameter and there is no user/lead found on that workspace with he given email, then we will create a new contact with `role` set to `lead`. {% /admonition %}    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_contact_from_conversation_with_http_info(conversation_id, contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The identifier for the conversation as given by Intercom. (required)
        :param str contact_id: The identifier for the contact as given by Intercom. (required)
        :param DetachContactFromConversationRequest body:
        :param IntercomVersion intercom_version:
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_id', 'contact_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_contact_from_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_id' is set
        if ('conversation_id' not in params or
                params['conversation_id'] is None):
            raise ValueError("Missing the required parameter `conversation_id` when calling `detach_contact_from_conversation`")  # noqa: E501
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `detach_contact_from_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'conversation_id' in params:
            path_params['conversation_id'] = params['conversation_id']  # noqa: E501
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/{conversation_id}/customers/{contact_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Conversation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_tag_from_conversation(self, conversation_id, tag_id, **kwargs):  # noqa: E501
        """Remove tag from a conversation  # noqa: E501

        You can remove tag from a specific conversation. This will return a tag object for the tag that was removed from the conversation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_tag_from_conversation(conversation_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: conversation_id (required)
        :param str tag_id: id (required)
        :param TagsTagIdBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_tag_from_conversation_with_http_info(conversation_id, tag_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_tag_from_conversation_with_http_info(conversation_id, tag_id, **kwargs)  # noqa: E501
            return data

    def detach_tag_from_conversation_with_http_info(self, conversation_id, tag_id, **kwargs):  # noqa: E501
        """Remove tag from a conversation  # noqa: E501

        You can remove tag from a specific conversation. This will return a tag object for the tag that was removed from the conversation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_tag_from_conversation_with_http_info(conversation_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: conversation_id (required)
        :param str tag_id: id (required)
        :param TagsTagIdBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_id', 'tag_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_tag_from_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_id' is set
        if ('conversation_id' not in params or
                params['conversation_id'] is None):
            raise ValueError("Missing the required parameter `conversation_id` when calling `detach_tag_from_conversation`")  # noqa: E501
        # verify the required parameter 'tag_id' is set
        if ('tag_id' not in params or
                params['tag_id'] is None):
            raise ValueError("Missing the required parameter `tag_id` when calling `detach_tag_from_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'conversation_id' in params:
            path_params['conversation_id'] = params['conversation_id']  # noqa: E501
        if 'tag_id' in params:
            path_params['tag_id'] = params['tag_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/{conversation_id}/tags/{tag_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_conversations(self, **kwargs):  # noqa: E501
        """List all conversations  # noqa: E501

        You can fetch a list of all conversations.  You can optionally request the result page size and the cursor to start after to fetch the result. {% admonition type=\"warning\" name=\"Pagination\" %}   You can use pagination to limit the number of results returned. The default is `20` results per page.   See the [pagination section](https://developers.intercom.com/docs/build-an-integration/learn-more/rest-apis/pagination/#pagination-for-list-apis) for more details on how to use the `starting_after` param. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_conversations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IntercomVersion intercom_version:
        :param int per_page: How many results per page
        :param str starting_after: String used to get the next page of conversations.
        :return: PaginatedConversationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_conversations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_conversations_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_conversations_with_http_info(self, **kwargs):  # noqa: E501
        """List all conversations  # noqa: E501

        You can fetch a list of all conversations.  You can optionally request the result page size and the cursor to start after to fetch the result. {% admonition type=\"warning\" name=\"Pagination\" %}   You can use pagination to limit the number of results returned. The default is `20` results per page.   See the [pagination section](https://developers.intercom.com/docs/build-an-integration/learn-more/rest-apis/pagination/#pagination-for-list-apis) for more details on how to use the `starting_after` param. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_conversations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IntercomVersion intercom_version:
        :param int per_page: How many results per page
        :param str starting_after: String used to get the next page of conversations.
        :return: PaginatedConversationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['intercom_version', 'per_page', 'starting_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_conversations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501
        if 'starting_after' in params:
            query_params.append(('starting_after', params['starting_after']))  # noqa: E501

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedConversationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def manage_conversation(self, conversation_id, **kwargs):  # noqa: E501
        """Manage a conversation  # noqa: E501

        For managing conversations you can: - Close a conversation - Snooze a conversation to reopen on a future date - Open a conversation which is `snoozed` or `closed` - Assign a conversation to an admin and/or team.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.manage_conversation(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The identifier for the conversation as given by Intercom. (required)
        :param ConversationIdPartsBody body:
        :param IntercomVersion intercom_version:
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.manage_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.manage_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
            return data

    def manage_conversation_with_http_info(self, conversation_id, **kwargs):  # noqa: E501
        """Manage a conversation  # noqa: E501

        For managing conversations you can: - Close a conversation - Snooze a conversation to reopen on a future date - Open a conversation which is `snoozed` or `closed` - Assign a conversation to an admin and/or team.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.manage_conversation_with_http_info(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The identifier for the conversation as given by Intercom. (required)
        :param ConversationIdPartsBody body:
        :param IntercomVersion intercom_version:
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method manage_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_id' is set
        if ('conversation_id' not in params or
                params['conversation_id'] is None):
            raise ValueError("Missing the required parameter `conversation_id` when calling `manage_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'conversation_id' in params:
            path_params['conversation_id'] = params['conversation_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/{conversation_id}/parts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Conversation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def redact_conversation(self, **kwargs):  # noqa: E501
        """Redact a conversation part  # noqa: E501

        You can redact a conversation part or the source message of a conversation (as seen in the source object).  {% admonition type=\"info\" name=\"Redacting parts and messages\" %} If you are redacting a conversation part, it must have a `body`. If you are redacting a source message, it must have been created by a contact. We will return a `conversation_part_not_redactable` error if these criteria are not met. {% /admonition %}    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redact_conversation(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RedactConversationRequest body:
        :param IntercomVersion intercom_version:
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.redact_conversation_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.redact_conversation_with_http_info(**kwargs)  # noqa: E501
            return data

    def redact_conversation_with_http_info(self, **kwargs):  # noqa: E501
        """Redact a conversation part  # noqa: E501

        You can redact a conversation part or the source message of a conversation (as seen in the source object).  {% admonition type=\"info\" name=\"Redacting parts and messages\" %} If you are redacting a conversation part, it must have a `body`. If you are redacting a source message, it must have been created by a contact. We will return a `conversation_part_not_redactable` error if these criteria are not met. {% /admonition %}    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.redact_conversation_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param RedactConversationRequest body:
        :param IntercomVersion intercom_version:
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method redact_conversation" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/redact', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Conversation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reply_conversation(self, conversation_id, **kwargs):  # noqa: E501
        """Reply to a conversation  # noqa: E501

        You can reply to a conversation with a message from an admin or on behalf of a contact, or with a note for admins.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reply_conversation(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The Intercom provisioned identifier for the conversation or the string \"last\" to reply to the last part of the conversation (required)
        :param ReplyConversationRequest body:
        :param IntercomVersion intercom_version:
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reply_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.reply_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
            return data

    def reply_conversation_with_http_info(self, conversation_id, **kwargs):  # noqa: E501
        """Reply to a conversation  # noqa: E501

        You can reply to a conversation with a message from an admin or on behalf of a contact, or with a note for admins.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reply_conversation_with_http_info(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The Intercom provisioned identifier for the conversation or the string \"last\" to reply to the last part of the conversation (required)
        :param ReplyConversationRequest body:
        :param IntercomVersion intercom_version:
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reply_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_id' is set
        if ('conversation_id' not in params or
                params['conversation_id'] is None):
            raise ValueError("Missing the required parameter `conversation_id` when calling `reply_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'conversation_id' in params:
            path_params['conversation_id'] = params['conversation_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/{conversation_id}/reply', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Conversation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_conversation(self, conversation_id, **kwargs):  # noqa: E501
        """Retrieve a conversation  # noqa: E501

         You can fetch the details of a single conversation.  This will return a single Conversation model with all its conversation parts.  {% admonition type=\"warning\" name=\"Hard limit of 500 parts\" %} The maximum number of conversation parts that can be returned via the API is 500. If you have more than that we will return the 500 most recent conversation parts. {% /admonition %}  For AI agent conversation metadata, please note that you need to have the agent enabled in your workspace, which is a [paid feature](https://www.intercom.com/help/en/articles/8205718-fin-resolutions#h_97f8c2e671).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_conversation(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The id of the conversation to target (required)
        :param IntercomVersion intercom_version:
        :param str display_as: Set to plaintext to retrieve conversation messages in plain text.
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
            return data

    def retrieve_conversation_with_http_info(self, conversation_id, **kwargs):  # noqa: E501
        """Retrieve a conversation  # noqa: E501

         You can fetch the details of a single conversation.  This will return a single Conversation model with all its conversation parts.  {% admonition type=\"warning\" name=\"Hard limit of 500 parts\" %} The maximum number of conversation parts that can be returned via the API is 500. If you have more than that we will return the 500 most recent conversation parts. {% /admonition %}  For AI agent conversation metadata, please note that you need to have the agent enabled in your workspace, which is a [paid feature](https://www.intercom.com/help/en/articles/8205718-fin-resolutions#h_97f8c2e671).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_conversation_with_http_info(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The id of the conversation to target (required)
        :param IntercomVersion intercom_version:
        :param str display_as: Set to plaintext to retrieve conversation messages in plain text.
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_id', 'intercom_version', 'display_as']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_id' is set
        if ('conversation_id' not in params or
                params['conversation_id'] is None):
            raise ValueError("Missing the required parameter `conversation_id` when calling `retrieve_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'conversation_id' in params:
            path_params['conversation_id'] = params['conversation_id']  # noqa: E501

        query_params = []
        if 'display_as' in params:
            query_params.append(('display_as', params['display_as']))  # noqa: E501

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/{conversation_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Conversation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_conversations(self, **kwargs):  # noqa: E501
        """Search conversations  # noqa: E501

        You can search for multiple conversations by the value of their attributes in order to fetch exactly which ones you want.  To search for conversations, you need to send a `POST` request to `https://api.intercom.io/conversations/search`.  This will accept a query object in the body which will define your filters in order to search for conversations. {% admonition type=\"warning\" name=\"Optimizing search queries\" %}   Search queries can be complex, so optimizing them can help the performance of your search.   Use the `AND` and `OR` operators to combine multiple filters to get the exact results you need and utilize   pagination to limit the number of results returned. The default is `20` results per page and maximum is `150`.   See the [pagination section](https://developers.intercom.com/docs/build-an-integration/learn-more/rest-apis/pagination/#example-search-conversations-request) for more details on how to use the `starting_after` param. {% /admonition %}  ### Nesting & Limitations  You can nest these filters in order to get even more granular insights that pinpoint exactly what you need. Example: (1 OR 2) AND (3 OR 4). There are some limitations to the amount of multiple's there can be: - There's a limit of max 2 nested filters - There's a limit of max 15 filters for each AND or OR group  ### Accepted Fields  Most keys listed as part of the The conversation model is searchable, whether writeable or not. The value you search for has to match the accepted type, otherwise the query will fail (ie. as `created_at` accepts a date, the `value` cannot be a string such as `\"foorbar\"`). The `source.body` field is unique as the search will not be performed against the entire value, but instead against every element of the value separately. For example, when searching for a conversation with a `\"I need support\"` body - the query should contain a `=` operator with the value `\"support\"` for such conversation to be returned. A query with a `=` operator and a `\"need support\"` value will not yield a result.  | Field                                     | Type                                                                                                                                                   | | :---------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------- | | id                                        | String                                                                                                                                                 | | created_at                                | Date (UNIX timestamp)                                                                                                                                  | | updated_at                                | Date (UNIX timestamp)                                                                                                                                  | | source.type                               | String<br>Accepted fields are `conversation`, `email`, `facebook`, `instagram`, `phone_call`, `phone_switch`, `push`, `sms`, `twitter` and `whatsapp`. | | source.id                                 | String                                                                                                                                                 | | source.delivered_as                       | String                                                                                                                                                 | | source.subject                            | String                                                                                                                                                 | | source.body                               | String                                                                                                                                                 | | source.author.id                          | String                                                                                                                                                 | | source.author.type                        | String                                                                                                                                                 | | source.author.name                        | String                                                                                                                                                 | | source.author.email                       | String                                                                                                                                                 | | source.url                                | String                                                                                                                                                 | | contact_ids                               | String                                                                                                                                                 | | teammate_ids                              | String                                                                                                                                                 | | admin_assignee_id                         | String                                                                                                                                                 | | team_assignee_id                          | String                                                                                                                                                 | | channel_initiated                         | String                                                                                                                                                 | | open                                      | Boolean                                                                                                                                                | | read                                      | Boolean                                                                                                                                                | | state                                     | String                                                                                                                                                 | | waiting_since                             | Date (UNIX timestamp)                                                                                                                                  | | snoozed_until                             | Date (UNIX timestamp)                                                                                                                                  | | tag_ids                                   | String                                                                                                                                                 | | priority                                  | String                                                                                                                                                 | | statistics.time_to_assignment             | Integer                                                                                                                                                | | statistics.time_to_admin_reply            | Integer                                                                                                                                                | | statistics.time_to_first_close            | Integer                                                                                                                                                | | statistics.time_to_last_close             | Integer                                                                                                                                                | | statistics.median_time_to_reply           | Integer                                                                                                                                                | | statistics.first_contact_reply_at         | Date (UNIX timestamp)                                                                                                                                  | | statistics.first_assignment_at            | Date (UNIX timestamp)                                                                                                                                  | | statistics.first_admin_reply_at           | Date (UNIX timestamp)                                                                                                                                  | | statistics.first_close_at                 | Date (UNIX timestamp)                                                                                                                                  | | statistics.last_assignment_at             | Date (UNIX timestamp)                                                                                                                                  | | statistics.last_assignment_admin_reply_at | Date (UNIX timestamp)                                                                                                                                  | | statistics.last_contact_reply_at          | Date (UNIX timestamp)                                                                                                                                  | | statistics.last_admin_reply_at            | Date (UNIX timestamp)                                                                                                                                  | | statistics.last_close_at                  | Date (UNIX timestamp)                                                                                                                                  | | statistics.last_closed_by_id              | String                                                                                                                                                 | | statistics.count_reopens                  | Integer                                                                                                                                                | | statistics.count_assignments              | Integer                                                                                                                                                | | statistics.count_conversation_parts       | Integer                                                                                                                                                | | conversation_rating.requested_at          | Date (UNIX timestamp)                                                                                                                                  | | conversation_rating.replied_at            | Date (UNIX timestamp)                                                                                                                                  | | conversation_rating.score                 | Integer                                                                                                                                                | | conversation_rating.remark                | String                                                                                                                                                 | | conversation_rating.contact_id            | String                                                                                                                                                 | | conversation_rating.admin_d               | String                                                                                                                                                 | | ai_agent_participated                     | Boolean                                                                                                                                                | | ai_agent.resolution_state                 | String                                                                                                                                                 | | ai_agent.last_answer_type                 | String                                                                                                                                                 | | ai_agent.rating                           | Integer                                                                                                                                                | | ai_agent.rating_remark                    | String                                                                                                                                                 | | ai_agent.source_type                      | String                                                                                                                                                 | | ai_agent.source_title                     | String                                                                                                                                                 |  ### Accepted Operators  The table below shows the operators you can use to define how you want to search for the value.  The operator should be put in as a string (`\"=\"`). The operator has to be compatible with the field's type  (eg. you cannot search with `>` for a given string value as it's only compatible for integer's and dates).  | Operator | Valid Types                    | Description                                                  | | :------- | :----------------------------- | :----------------------------------------------------------- | | =        | All                            | Equals                                                       | | !=       | All                            | Doesn't Equal                                                | | IN       | All                            | In  Shortcut for `OR` queries  Values most be in Array       | | NIN      | All                            | Not In  Shortcut for `OR !` queries  Values must be in Array | | >        | Integer  Date (UNIX Timestamp) | Greater (or equal) than                                      | | <       | Integer  Date (UNIX Timestamp) | Lower (or equal) than                                        | | ~        | String                         | Contains                                                     | | !~       | String                         | Doesn't Contain                                              | | ^        | String                         | Starts With                                                  | | $        | String                         | Ends With                                                    |   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_conversations(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SearchRequest body:
        :param IntercomVersion intercom_version:
        :return: PaginatedConversationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_conversations_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_conversations_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_conversations_with_http_info(self, **kwargs):  # noqa: E501
        """Search conversations  # noqa: E501

        You can search for multiple conversations by the value of their attributes in order to fetch exactly which ones you want.  To search for conversations, you need to send a `POST` request to `https://api.intercom.io/conversations/search`.  This will accept a query object in the body which will define your filters in order to search for conversations. {% admonition type=\"warning\" name=\"Optimizing search queries\" %}   Search queries can be complex, so optimizing them can help the performance of your search.   Use the `AND` and `OR` operators to combine multiple filters to get the exact results you need and utilize   pagination to limit the number of results returned. The default is `20` results per page and maximum is `150`.   See the [pagination section](https://developers.intercom.com/docs/build-an-integration/learn-more/rest-apis/pagination/#example-search-conversations-request) for more details on how to use the `starting_after` param. {% /admonition %}  ### Nesting & Limitations  You can nest these filters in order to get even more granular insights that pinpoint exactly what you need. Example: (1 OR 2) AND (3 OR 4). There are some limitations to the amount of multiple's there can be: - There's a limit of max 2 nested filters - There's a limit of max 15 filters for each AND or OR group  ### Accepted Fields  Most keys listed as part of the The conversation model is searchable, whether writeable or not. The value you search for has to match the accepted type, otherwise the query will fail (ie. as `created_at` accepts a date, the `value` cannot be a string such as `\"foorbar\"`). The `source.body` field is unique as the search will not be performed against the entire value, but instead against every element of the value separately. For example, when searching for a conversation with a `\"I need support\"` body - the query should contain a `=` operator with the value `\"support\"` for such conversation to be returned. A query with a `=` operator and a `\"need support\"` value will not yield a result.  | Field                                     | Type                                                                                                                                                   | | :---------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------- | | id                                        | String                                                                                                                                                 | | created_at                                | Date (UNIX timestamp)                                                                                                                                  | | updated_at                                | Date (UNIX timestamp)                                                                                                                                  | | source.type                               | String<br>Accepted fields are `conversation`, `email`, `facebook`, `instagram`, `phone_call`, `phone_switch`, `push`, `sms`, `twitter` and `whatsapp`. | | source.id                                 | String                                                                                                                                                 | | source.delivered_as                       | String                                                                                                                                                 | | source.subject                            | String                                                                                                                                                 | | source.body                               | String                                                                                                                                                 | | source.author.id                          | String                                                                                                                                                 | | source.author.type                        | String                                                                                                                                                 | | source.author.name                        | String                                                                                                                                                 | | source.author.email                       | String                                                                                                                                                 | | source.url                                | String                                                                                                                                                 | | contact_ids                               | String                                                                                                                                                 | | teammate_ids                              | String                                                                                                                                                 | | admin_assignee_id                         | String                                                                                                                                                 | | team_assignee_id                          | String                                                                                                                                                 | | channel_initiated                         | String                                                                                                                                                 | | open                                      | Boolean                                                                                                                                                | | read                                      | Boolean                                                                                                                                                | | state                                     | String                                                                                                                                                 | | waiting_since                             | Date (UNIX timestamp)                                                                                                                                  | | snoozed_until                             | Date (UNIX timestamp)                                                                                                                                  | | tag_ids                                   | String                                                                                                                                                 | | priority                                  | String                                                                                                                                                 | | statistics.time_to_assignment             | Integer                                                                                                                                                | | statistics.time_to_admin_reply            | Integer                                                                                                                                                | | statistics.time_to_first_close            | Integer                                                                                                                                                | | statistics.time_to_last_close             | Integer                                                                                                                                                | | statistics.median_time_to_reply           | Integer                                                                                                                                                | | statistics.first_contact_reply_at         | Date (UNIX timestamp)                                                                                                                                  | | statistics.first_assignment_at            | Date (UNIX timestamp)                                                                                                                                  | | statistics.first_admin_reply_at           | Date (UNIX timestamp)                                                                                                                                  | | statistics.first_close_at                 | Date (UNIX timestamp)                                                                                                                                  | | statistics.last_assignment_at             | Date (UNIX timestamp)                                                                                                                                  | | statistics.last_assignment_admin_reply_at | Date (UNIX timestamp)                                                                                                                                  | | statistics.last_contact_reply_at          | Date (UNIX timestamp)                                                                                                                                  | | statistics.last_admin_reply_at            | Date (UNIX timestamp)                                                                                                                                  | | statistics.last_close_at                  | Date (UNIX timestamp)                                                                                                                                  | | statistics.last_closed_by_id              | String                                                                                                                                                 | | statistics.count_reopens                  | Integer                                                                                                                                                | | statistics.count_assignments              | Integer                                                                                                                                                | | statistics.count_conversation_parts       | Integer                                                                                                                                                | | conversation_rating.requested_at          | Date (UNIX timestamp)                                                                                                                                  | | conversation_rating.replied_at            | Date (UNIX timestamp)                                                                                                                                  | | conversation_rating.score                 | Integer                                                                                                                                                | | conversation_rating.remark                | String                                                                                                                                                 | | conversation_rating.contact_id            | String                                                                                                                                                 | | conversation_rating.admin_d               | String                                                                                                                                                 | | ai_agent_participated                     | Boolean                                                                                                                                                | | ai_agent.resolution_state                 | String                                                                                                                                                 | | ai_agent.last_answer_type                 | String                                                                                                                                                 | | ai_agent.rating                           | Integer                                                                                                                                                | | ai_agent.rating_remark                    | String                                                                                                                                                 | | ai_agent.source_type                      | String                                                                                                                                                 | | ai_agent.source_title                     | String                                                                                                                                                 |  ### Accepted Operators  The table below shows the operators you can use to define how you want to search for the value.  The operator should be put in as a string (`\"=\"`). The operator has to be compatible with the field's type  (eg. you cannot search with `>` for a given string value as it's only compatible for integer's and dates).  | Operator | Valid Types                    | Description                                                  | | :------- | :----------------------------- | :----------------------------------------------------------- | | =        | All                            | Equals                                                       | | !=       | All                            | Doesn't Equal                                                | | IN       | All                            | In  Shortcut for `OR` queries  Values most be in Array       | | NIN      | All                            | Not In  Shortcut for `OR !` queries  Values must be in Array | | >        | Integer  Date (UNIX Timestamp) | Greater (or equal) than                                      | | <       | Integer  Date (UNIX Timestamp) | Lower (or equal) than                                        | | ~        | String                         | Contains                                                     | | !~       | String                         | Doesn't Contain                                              | | ^        | String                         | Starts With                                                  | | $        | String                         | Ends With                                                    |   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_conversations_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SearchRequest body:
        :param IntercomVersion intercom_version:
        :return: PaginatedConversationResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_conversations" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='PaginatedConversationResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_conversation(self, conversation_id, **kwargs):  # noqa: E501
        """Update a conversation  # noqa: E501

         You can update an existing conversation.  {% admonition type=\"info\" name=\"Replying and other actions\" %} If you want to reply to a coveration or take an action such as assign, unassign, open, close or snooze, take a look at the reply and manage endpoints. {% /admonition %}    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_conversation(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The id of the conversation to target (required)
        :param UpdateConversationRequest body:
        :param IntercomVersion intercom_version:
        :param str display_as: Set to plaintext to retrieve conversation messages in plain text.
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_conversation_with_http_info(conversation_id, **kwargs)  # noqa: E501
            return data

    def update_conversation_with_http_info(self, conversation_id, **kwargs):  # noqa: E501
        """Update a conversation  # noqa: E501

         You can update an existing conversation.  {% admonition type=\"info\" name=\"Replying and other actions\" %} If you want to reply to a coveration or take an action such as assign, unassign, open, close or snooze, take a look at the reply and manage endpoints. {% /admonition %}    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_conversation_with_http_info(conversation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str conversation_id: The id of the conversation to target (required)
        :param UpdateConversationRequest body:
        :param IntercomVersion intercom_version:
        :param str display_as: Set to plaintext to retrieve conversation messages in plain text.
        :return: Conversation
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['conversation_id', 'body', 'intercom_version', 'display_as']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_conversation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'conversation_id' is set
        if ('conversation_id' not in params or
                params['conversation_id'] is None):
            raise ValueError("Missing the required parameter `conversation_id` when calling `update_conversation`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'conversation_id' in params:
            path_params['conversation_id'] = params['conversation_id']  # noqa: E501

        query_params = []
        if 'display_as' in params:
            query_params.append(('display_as', params['display_as']))  # noqa: E501

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/conversations/{conversation_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Conversation',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
