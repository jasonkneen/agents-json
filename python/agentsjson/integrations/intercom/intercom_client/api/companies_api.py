# coding: utf-8

"""
    Intercom API

    The intercom API reference.  # noqa: E501

    OpenAPI spec version: 2.11
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from ..api_client import ApiClient


class CompaniesApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def attach_contact_to_a_company(self, contact_id, **kwargs):  # noqa: E501
        """Attach a Contact to a Company  # noqa: E501

        You can attach a company to a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_contact_to_a_company(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param ContactIdCompaniesBody body:
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.attach_contact_to_a_company_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.attach_contact_to_a_company_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def attach_contact_to_a_company_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Attach a Contact to a Company  # noqa: E501

        You can attach a company to a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_contact_to_a_company_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param ContactIdCompaniesBody body:
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_contact_to_a_company" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `attach_contact_to_a_company`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/companies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Company',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_or_update_company(self, **kwargs):  # noqa: E501
        """Create or Update a company  # noqa: E501

        You can create or update a company.  Companies will be only visible in Intercom when there is at least one associated user.  Companies are looked up via `company_id` in a `POST` request, if not found via `company_id`, the new company will be created, if found, that company will be updated.  {% admonition type=\"attention\" name=\"Using `company_id`\" %}   You can set a unique `company_id` value when creating a company. However, it is not possible to update `company_id`. Be sure to set a unique value once upon creation of the company. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_company(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateOrUpdateCompanyRequest body:
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_or_update_company_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_or_update_company_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_or_update_company_with_http_info(self, **kwargs):  # noqa: E501
        """Create or Update a company  # noqa: E501

        You can create or update a company.  Companies will be only visible in Intercom when there is at least one associated user.  Companies are looked up via `company_id` in a `POST` request, if not found via `company_id`, the new company will be created, if found, that company will be updated.  {% admonition type=\"attention\" name=\"Using `company_id`\" %}   You can set a unique `company_id` value when creating a company. However, it is not possible to update `company_id`. Be sure to set a unique value once upon creation of the company. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_or_update_company_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateOrUpdateCompanyRequest body:
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_or_update_company" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/companies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Company',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_company(self, company_id, **kwargs):  # noqa: E501
        """Delete a company  # noqa: E501

        You can delete a single company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_company(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: DeletedCompanyObject
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_company_with_http_info(company_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_company_with_http_info(company_id, **kwargs)  # noqa: E501
            return data

    def delete_company_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Delete a company  # noqa: E501

        You can delete a single company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_company_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: DeletedCompanyObject
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['company_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_company" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'company_id' is set
        if ('company_id' not in params or
                params['company_id'] is None):
            raise ValueError("Missing the required parameter `company_id` when calling `delete_company`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in params:
            path_params['company_id'] = params['company_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/companies/{company_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DeletedCompanyObject',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_contact_from_a_company(self, contact_id, company_id, **kwargs):  # noqa: E501
        """Detach a contact from a company  # noqa: E501

        You can detach a company from a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_contact_from_a_company(contact_id, company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_contact_from_a_company_with_http_info(contact_id, company_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_contact_from_a_company_with_http_info(contact_id, company_id, **kwargs)  # noqa: E501
            return data

    def detach_contact_from_a_company_with_http_info(self, contact_id, company_id, **kwargs):  # noqa: E501
        """Detach a contact from a company  # noqa: E501

        You can detach a company from a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_contact_from_a_company_with_http_info(contact_id, company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'company_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_contact_from_a_company" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `detach_contact_from_a_company`")  # noqa: E501
        # verify the required parameter 'company_id' is set
        if ('company_id' not in params or
                params['company_id'] is None):
            raise ValueError("Missing the required parameter `company_id` when calling `detach_contact_from_a_company`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501
        if 'company_id' in params:
            path_params['company_id'] = params['company_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/companies/{company_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Company',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_all_companies(self, **kwargs):  # noqa: E501
        """List all companies  # noqa: E501

        You can list companies. The company list is sorted by the `last_request_at` field and by default is ordered descending, most recently requested first.  Note that the API does not include companies who have no associated users in list responses.  When using the Companies endpoint and the pages object to iterate through the returned companies, there is a limit of 10,000 Companies that can be returned. If you need to list or iterate on more than 10,000 Companies, please use the [Scroll API](https://developers.intercom.com/reference#iterating-over-all-companies). {% admonition type=\"warning\" name=\"Pagination\" %}   You can use pagination to limit the number of results returned. The default is `20` results per page.   See the [pagination section](https://developers.intercom.com/docs/build-an-integration/learn-more/rest-apis/pagination/#pagination-for-list-apis) for more details on how to use the `starting_after` param. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_companies(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to return per page. Defaults to 15
        :param str order: `asc` or `desc`. Return the companies in ascending or descending order. Defaults to desc
        :return: CompanyList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_all_companies_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_all_companies_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_all_companies_with_http_info(self, **kwargs):  # noqa: E501
        """List all companies  # noqa: E501

        You can list companies. The company list is sorted by the `last_request_at` field and by default is ordered descending, most recently requested first.  Note that the API does not include companies who have no associated users in list responses.  When using the Companies endpoint and the pages object to iterate through the returned companies, there is a limit of 10,000 Companies that can be returned. If you need to list or iterate on more than 10,000 Companies, please use the [Scroll API](https://developers.intercom.com/reference#iterating-over-all-companies). {% admonition type=\"warning\" name=\"Pagination\" %}   You can use pagination to limit the number of results returned. The default is `20` results per page.   See the [pagination section](https://developers.intercom.com/docs/build-an-integration/learn-more/rest-apis/pagination/#pagination-for-list-apis) for more details on how to use the `starting_after` param. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_all_companies_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to return per page. Defaults to 15
        :param str order: `asc` or `desc`. Return the companies in ascending or descending order. Defaults to desc
        :return: CompanyList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['intercom_version', 'page', 'per_page', 'order']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_all_companies" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501
        if 'order' in params:
            query_params.append(('order', params['order']))  # noqa: E501

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/companies/list', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CompanyList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_attached_contacts(self, company_id, **kwargs):  # noqa: E501
        """List attached contacts  # noqa: E501

        You can fetch a list of all contacts that belong to a company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_attached_contacts(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to return per page. Defaults to 15
        :return: CompanyAttachedContacts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_attached_contacts_with_http_info(company_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_attached_contacts_with_http_info(company_id, **kwargs)  # noqa: E501
            return data

    def list_attached_contacts_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """List attached contacts  # noqa: E501

        You can fetch a list of all contacts that belong to a company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_attached_contacts_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to return per page. Defaults to 15
        :return: CompanyAttachedContacts
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['company_id', 'intercom_version', 'page', 'per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_attached_contacts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'company_id' is set
        if ('company_id' not in params or
                params['company_id'] is None):
            raise ValueError("Missing the required parameter `company_id` when calling `list_attached_contacts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in params:
            path_params['company_id'] = params['company_id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/companies/{company_id}/contacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CompanyAttachedContacts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_attached_segments_for_companies(self, company_id, **kwargs):  # noqa: E501
        """List attached segments for companies  # noqa: E501

        You can fetch a list of all segments that belong to a company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_attached_segments_for_companies(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: CompanyAttachedSegments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_attached_segments_for_companies_with_http_info(company_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_attached_segments_for_companies_with_http_info(company_id, **kwargs)  # noqa: E501
            return data

    def list_attached_segments_for_companies_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """List attached segments for companies  # noqa: E501

        You can fetch a list of all segments that belong to a company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_attached_segments_for_companies_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: CompanyAttachedSegments
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['company_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_attached_segments_for_companies" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'company_id' is set
        if ('company_id' not in params or
                params['company_id'] is None):
            raise ValueError("Missing the required parameter `company_id` when calling `list_attached_segments_for_companies`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in params:
            path_params['company_id'] = params['company_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/companies/{company_id}/segments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CompanyAttachedSegments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_companies_for_a_contact(self, contact_id, **kwargs):  # noqa: E501
        """List attached companies for contact  # noqa: E501

        You can fetch a list of companies that are associated to a contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_companies_for_a_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to display per page. Defaults to 15
        :return: ContactAttachedCompanies
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_companies_for_a_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_companies_for_a_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def list_companies_for_a_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """List attached companies for contact  # noqa: E501

        You can fetch a list of companies that are associated to a contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_companies_for_a_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to display per page. Defaults to 15
        :return: ContactAttachedCompanies
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'intercom_version', 'page', 'per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_companies_for_a_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `list_companies_for_a_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/companies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContactAttachedCompanies',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_a_company_by_id(self, company_id, **kwargs):  # noqa: E501
        """Retrieve a company by ID  # noqa: E501

        You can fetch a single company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_a_company_by_id(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_a_company_by_id_with_http_info(company_id, **kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_a_company_by_id_with_http_info(company_id, **kwargs)  # noqa: E501
            return data

    def retrieve_a_company_by_id_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Retrieve a company by ID  # noqa: E501

        You can fetch a single company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_a_company_by_id_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['company_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_a_company_by_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'company_id' is set
        if ('company_id' not in params or
                params['company_id'] is None):
            raise ValueError("Missing the required parameter `company_id` when calling `retrieve_a_company_by_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in params:
            path_params['company_id'] = params['company_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/companies/{company_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Company',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def retrieve_company(self, **kwargs):  # noqa: E501
        """Retrieve companies  # noqa: E501

        You can fetch a single company by passing in `company_id` or `name`.    `https://api.intercom.io/companies?name={name}`    `https://api.intercom.io/companies?company_id={company_id}`  You can fetch all companies and filter by `segment_id` or `tag_id` as a query parameter.    `https://api.intercom.io/companies?tag_id={tag_id}`    `https://api.intercom.io/companies?segment_id={segment_id}`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_company(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IntercomVersion intercom_version:
        :param str name: The `name` of the company to filter by.
        :param str company_id: The `company_id` of the company to filter by.
        :param str tag_id: The `tag_id` of the company to filter by.
        :param str segment_id: The `segment_id` of the company to filter by.
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to display per page. Defaults to 15
        :return: CompanyList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.retrieve_company_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.retrieve_company_with_http_info(**kwargs)  # noqa: E501
            return data

    def retrieve_company_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieve companies  # noqa: E501

        You can fetch a single company by passing in `company_id` or `name`.    `https://api.intercom.io/companies?name={name}`    `https://api.intercom.io/companies?company_id={company_id}`  You can fetch all companies and filter by `segment_id` or `tag_id` as a query parameter.    `https://api.intercom.io/companies?tag_id={tag_id}`    `https://api.intercom.io/companies?segment_id={segment_id}`   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.retrieve_company_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IntercomVersion intercom_version:
        :param str name: The `name` of the company to filter by.
        :param str company_id: The `company_id` of the company to filter by.
        :param str tag_id: The `tag_id` of the company to filter by.
        :param str segment_id: The `segment_id` of the company to filter by.
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to display per page. Defaults to 15
        :return: CompanyList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['intercom_version', 'name', 'company_id', 'tag_id', 'segment_id', 'page', 'per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_company" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'company_id' in params:
            query_params.append(('company_id', params['company_id']))  # noqa: E501
        if 'tag_id' in params:
            query_params.append(('tag_id', params['tag_id']))  # noqa: E501
        if 'segment_id' in params:
            query_params.append(('segment_id', params['segment_id']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/companies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CompanyList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scroll_over_all_companies(self, **kwargs):  # noqa: E501
        """Scroll over all companies  # noqa: E501

              The `list all companies` functionality does not work well for huge datasets, and can result in errors and performance problems when paging deeply. The Scroll API provides an efficient mechanism for iterating over all companies in a dataset.  - Each app can only have 1 scroll open at a time. You'll get an error message if you try to have more than one open per app. - If the scroll isn't used for 1 minute, it expires and calls with that scroll param will fail - If the end of the scroll is reached, \"companies\" will be empty and the scroll parameter will expire  {% admonition type=\"info\" name=\"Scroll Parameter\" %}   You can get the first page of companies by simply sending a GET request to the scroll endpoint.   For subsequent requests you will need to use the scroll parameter from the response. {% /admonition %} {% admonition type=\"danger\" name=\"Scroll network timeouts\" %}   Since scroll is often used on large datasets network errors such as timeouts can be encountered. When this occurs you will see a HTTP 500 error with the following message:   \"Request failed due to an internal network error. Please restart the scroll operation.\"   If this happens, you will need to restart your scroll query: It is not possible to continue from a specific point when using scroll. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scroll_over_all_companies(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IntercomVersion intercom_version:
        :param str scroll_param:
        :return: CompanyScroll
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.scroll_over_all_companies_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.scroll_over_all_companies_with_http_info(**kwargs)  # noqa: E501
            return data

    def scroll_over_all_companies_with_http_info(self, **kwargs):  # noqa: E501
        """Scroll over all companies  # noqa: E501

              The `list all companies` functionality does not work well for huge datasets, and can result in errors and performance problems when paging deeply. The Scroll API provides an efficient mechanism for iterating over all companies in a dataset.  - Each app can only have 1 scroll open at a time. You'll get an error message if you try to have more than one open per app. - If the scroll isn't used for 1 minute, it expires and calls with that scroll param will fail - If the end of the scroll is reached, \"companies\" will be empty and the scroll parameter will expire  {% admonition type=\"info\" name=\"Scroll Parameter\" %}   You can get the first page of companies by simply sending a GET request to the scroll endpoint.   For subsequent requests you will need to use the scroll parameter from the response. {% /admonition %} {% admonition type=\"danger\" name=\"Scroll network timeouts\" %}   Since scroll is often used on large datasets network errors such as timeouts can be encountered. When this occurs you will see a HTTP 500 error with the following message:   \"Request failed due to an internal network error. Please restart the scroll operation.\"   If this happens, you will need to restart your scroll query: It is not possible to continue from a specific point when using scroll. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scroll_over_all_companies_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IntercomVersion intercom_version:
        :param str scroll_param:
        :return: CompanyScroll
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['intercom_version', 'scroll_param']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scroll_over_all_companies" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'scroll_param' in params:
            query_params.append(('scroll_param', params['scroll_param']))  # noqa: E501

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/companies/scroll', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CompanyScroll',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_company(self, company_id, **kwargs):  # noqa: E501
        """Update a company  # noqa: E501

        You can update a single company using the Intercom provisioned `id`.  {% admonition type=\"attention\" name=\"Using `company_id`\" %}   When updating a company it is not possible to update `company_id`. This can only be set once upon creation of the company. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_company(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_company_with_http_info(company_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_company_with_http_info(company_id, **kwargs)  # noqa: E501
            return data

    def update_company_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """Update a company  # noqa: E501

        You can update a single company using the Intercom provisioned `id`.  {% admonition type=\"attention\" name=\"Using `company_id`\" %}   When updating a company it is not possible to update `company_id`. This can only be set once upon creation of the company. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_company_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['company_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_company" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'company_id' is set
        if ('company_id' not in params or
                params['company_id'] is None):
            raise ValueError("Missing the required parameter `company_id` when calling `update_company`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in params:
            path_params['company_id'] = params['company_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/companies/{company_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Company',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
