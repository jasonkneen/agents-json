# coding: utf-8

"""
    Intercom API

    The intercom API reference.  # noqa: E501

    OpenAPI spec version: 2.11
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from ..api_client import ApiClient


class ContactsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def archive_contact(self, contact_id, **kwargs):  # noqa: E501
        """Archive contact  # noqa: E501

        You can archive a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: id (required)
        :param IntercomVersion intercom_version:
        :return: ContactArchived
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.archive_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.archive_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def archive_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Archive contact  # noqa: E501

        You can archive a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.archive_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: id (required)
        :param IntercomVersion intercom_version:
        :return: ContactArchived
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method archive_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `archive_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/archive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContactArchived',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def attach_contact_to_a_company(self, contact_id, **kwargs):  # noqa: E501
        """Attach a Contact to a Company  # noqa: E501

        You can attach a company to a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_contact_to_a_company(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param ContactIdCompaniesBody body:
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.attach_contact_to_a_company_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.attach_contact_to_a_company_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def attach_contact_to_a_company_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Attach a Contact to a Company  # noqa: E501

        You can attach a company to a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_contact_to_a_company_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param ContactIdCompaniesBody body:
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_contact_to_a_company" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `attach_contact_to_a_company`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/companies', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Company',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def attach_subscription_type_to_contact(self, contact_id, **kwargs):  # noqa: E501
        """Add subscription to a contact  # noqa: E501

        You can add a specific subscription to a contact. In Intercom, we have two different subscription types based on user consent - opt-out and opt-in:    1.Attaching a contact to an opt-out subscription type will opt that user out from receiving messages related to that subscription type.    2.Attaching a contact to an opt-in subscription type will opt that user in to receiving messages related to that subscription type.  This will return a subscription type model for the subscription type that was added to the contact.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_subscription_type_to_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param ContactIdSubscriptionsBody body:
        :param IntercomVersion intercom_version:
        :return: SubscriptionType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.attach_subscription_type_to_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.attach_subscription_type_to_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def attach_subscription_type_to_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Add subscription to a contact  # noqa: E501

        You can add a specific subscription to a contact. In Intercom, we have two different subscription types based on user consent - opt-out and opt-in:    1.Attaching a contact to an opt-out subscription type will opt that user out from receiving messages related to that subscription type.    2.Attaching a contact to an opt-in subscription type will opt that user in to receiving messages related to that subscription type.  This will return a subscription type model for the subscription type that was added to the contact.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_subscription_type_to_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param ContactIdSubscriptionsBody body:
        :param IntercomVersion intercom_version:
        :return: SubscriptionType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_subscription_type_to_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `attach_subscription_type_to_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/subscriptions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SubscriptionType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def attach_tag_to_contact(self, contact_id, **kwargs):  # noqa: E501
        """Add tag to a contact  # noqa: E501

        You can tag a specific contact. This will return a tag object for the tag that was added to the contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_tag_to_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param ContactIdTagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.attach_tag_to_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.attach_tag_to_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def attach_tag_to_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Add tag to a contact  # noqa: E501

        You can tag a specific contact. This will return a tag object for the tag that was added to the contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attach_tag_to_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param ContactIdTagsBody body:
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attach_tag_to_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `attach_tag_to_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/tags', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_contact(self, **kwargs):  # noqa: E501
        """Create contact  # noqa: E501

        You can create a new contact (ie. user or lead).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateContactRequest body:
        :param IntercomVersion intercom_version:
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_contact_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_contact_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_contact_with_http_info(self, **kwargs):  # noqa: E501
        """Create contact  # noqa: E501

        You can create a new contact (ie. user or lead).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_contact_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CreateContactRequest body:
        :param IntercomVersion intercom_version:
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_contact" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_note(self, contact_id, **kwargs):  # noqa: E501
        """Create a note  # noqa: E501

        You can add a note to a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_note(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier of a given contact. (required)
        :param ContactIdNotesBody body:
        :param IntercomVersion intercom_version:
        :return: Note
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_note_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_note_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def create_note_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Create a note  # noqa: E501

        You can add a note to a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_note_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier of a given contact. (required)
        :param ContactIdNotesBody body:
        :param IntercomVersion intercom_version:
        :return: Note
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_note" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `create_note`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/notes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Note',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_contact(self, contact_id, **kwargs):  # noqa: E501
        """Delete a contact  # noqa: E501

        You can delete a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: id (required)
        :param IntercomVersion intercom_version:
        :return: ContactDeleted
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def delete_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Delete a contact  # noqa: E501

        You can delete a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: id (required)
        :param IntercomVersion intercom_version:
        :return: ContactDeleted
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `delete_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContactDeleted',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_contact_from_a_company(self, contact_id, company_id, **kwargs):  # noqa: E501
        """Detach a contact from a company  # noqa: E501

        You can detach a company from a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_contact_from_a_company(contact_id, company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_contact_from_a_company_with_http_info(contact_id, company_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_contact_from_a_company_with_http_info(contact_id, company_id, **kwargs)  # noqa: E501
            return data

    def detach_contact_from_a_company_with_http_info(self, contact_id, company_id, **kwargs):  # noqa: E501
        """Detach a contact from a company  # noqa: E501

        You can detach a company from a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_contact_from_a_company_with_http_info(contact_id, company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: Company
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'company_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_contact_from_a_company" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `detach_contact_from_a_company`")  # noqa: E501
        # verify the required parameter 'company_id' is set
        if ('company_id' not in params or
                params['company_id'] is None):
            raise ValueError("Missing the required parameter `company_id` when calling `detach_contact_from_a_company`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501
        if 'company_id' in params:
            path_params['company_id'] = params['company_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/companies/{company_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Company',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_subscription_type_to_contact(self, contact_id, subscription_id, **kwargs):  # noqa: E501
        """Remove subscription from a contact  # noqa: E501

        You can remove a specific subscription from a contact. This will return a subscription type model for the subscription type that was removed from the contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_subscription_type_to_contact(contact_id, subscription_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param str subscription_id: The unique identifier for the subscription type which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: SubscriptionType
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_subscription_type_to_contact_with_http_info(contact_id, subscription_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_subscription_type_to_contact_with_http_info(contact_id, subscription_id, **kwargs)  # noqa: E501
            return data

    def detach_subscription_type_to_contact_with_http_info(self, contact_id, subscription_id, **kwargs):  # noqa: E501
        """Remove subscription from a contact  # noqa: E501

        You can remove a specific subscription from a contact. This will return a subscription type model for the subscription type that was removed from the contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_subscription_type_to_contact_with_http_info(contact_id, subscription_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param str subscription_id: The unique identifier for the subscription type which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: SubscriptionType
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'subscription_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_subscription_type_to_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `detach_subscription_type_to_contact`")  # noqa: E501
        # verify the required parameter 'subscription_id' is set
        if ('subscription_id' not in params or
                params['subscription_id'] is None):
            raise ValueError("Missing the required parameter `subscription_id` when calling `detach_subscription_type_to_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501
        if 'subscription_id' in params:
            path_params['subscription_id'] = params['subscription_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/subscriptions/{subscription_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SubscriptionType',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def detach_tag_from_contact(self, contact_id, tag_id, **kwargs):  # noqa: E501
        """Remove tag from a contact  # noqa: E501

        You can remove tag from a specific contact. This will return a tag object for the tag that was removed from the contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_tag_from_contact(contact_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param str tag_id: The unique identifier for the tag which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.detach_tag_from_contact_with_http_info(contact_id, tag_id, **kwargs)  # noqa: E501
        else:
            (data) = self.detach_tag_from_contact_with_http_info(contact_id, tag_id, **kwargs)  # noqa: E501
            return data

    def detach_tag_from_contact_with_http_info(self, contact_id, tag_id, **kwargs):  # noqa: E501
        """Remove tag from a contact  # noqa: E501

        You can remove tag from a specific contact. This will return a tag object for the tag that was removed from the contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.detach_tag_from_contact_with_http_info(contact_id, tag_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param str tag_id: The unique identifier for the tag which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: Tag
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'tag_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method detach_tag_from_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `detach_tag_from_contact`")  # noqa: E501
        # verify the required parameter 'tag_id' is set
        if ('tag_id' not in params or
                params['tag_id'] is None):
            raise ValueError("Missing the required parameter `tag_id` when calling `detach_tag_from_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501
        if 'tag_id' in params:
            path_params['tag_id'] = params['tag_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/tags/{tag_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Tag',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_attached_contacts(self, company_id, **kwargs):  # noqa: E501
        """List attached contacts  # noqa: E501

        You can fetch a list of all contacts that belong to a company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_attached_contacts(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to return per page. Defaults to 15
        :return: CompanyAttachedContacts
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_attached_contacts_with_http_info(company_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_attached_contacts_with_http_info(company_id, **kwargs)  # noqa: E501
            return data

    def list_attached_contacts_with_http_info(self, company_id, **kwargs):  # noqa: E501
        """List attached contacts  # noqa: E501

        You can fetch a list of all contacts that belong to a company.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_attached_contacts_with_http_info(company_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str company_id: The unique identifier for the company which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to return per page. Defaults to 15
        :return: CompanyAttachedContacts
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['company_id', 'intercom_version', 'page', 'per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_attached_contacts" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'company_id' is set
        if ('company_id' not in params or
                params['company_id'] is None):
            raise ValueError("Missing the required parameter `company_id` when calling `list_attached_contacts`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'company_id' in params:
            path_params['company_id'] = params['company_id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/companies/{company_id}/contacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CompanyAttachedContacts',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_companies_for_a_contact(self, contact_id, **kwargs):  # noqa: E501
        """List attached companies for contact  # noqa: E501

        You can fetch a list of companies that are associated to a contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_companies_for_a_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to display per page. Defaults to 15
        :return: ContactAttachedCompanies
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_companies_for_a_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_companies_for_a_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def list_companies_for_a_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """List attached companies for contact  # noqa: E501

        You can fetch a list of companies that are associated to a contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_companies_for_a_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to display per page. Defaults to 15
        :return: ContactAttachedCompanies
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'intercom_version', 'page', 'per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_companies_for_a_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `list_companies_for_a_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/companies', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContactAttachedCompanies',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_contacts(self, **kwargs):  # noqa: E501
        """List all contacts  # noqa: E501

        You can fetch a list of all contacts (ie. users or leads) in your workspace. {% admonition type=\"warning\" name=\"Pagination\" %}   You can use pagination to limit the number of results returned. The default is `50` results per page.   See the [pagination section](https://developers.intercom.com/docs/build-an-integration/learn-more/rest-apis/pagination/#pagination-for-list-apis) for more details on how to use the `starting_after` param. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_contacts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to display per page. Defaults to 15
        :param str starting_after: String used to get the next page of conversations.
        :return: ContactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_contacts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.list_contacts_with_http_info(**kwargs)  # noqa: E501
            return data

    def list_contacts_with_http_info(self, **kwargs):  # noqa: E501
        """List all contacts  # noqa: E501

        You can fetch a list of all contacts (ie. users or leads) in your workspace. {% admonition type=\"warning\" name=\"Pagination\" %}   You can use pagination to limit the number of results returned. The default is `50` results per page.   See the [pagination section](https://developers.intercom.com/docs/build-an-integration/learn-more/rest-apis/pagination/#pagination-for-list-apis) for more details on how to use the `starting_after` param. {% /admonition %}   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_contacts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to display per page. Defaults to 15
        :param str starting_after: String used to get the next page of conversations.
        :return: ContactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['intercom_version', 'page', 'per_page', 'starting_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_contacts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501
        if 'starting_after' in params:
            query_params.append(('starting_after', params['starting_after']))  # noqa: E501

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_notes(self, contact_id, **kwargs):  # noqa: E501
        """List all notes  # noqa: E501

        You can fetch a list of notes that are associated to a contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_notes(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier of a contact. (required)
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to display per page. Defaults to 15
        :return: NoteList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_notes_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_notes_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def list_notes_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """List all notes  # noqa: E501

        You can fetch a list of notes that are associated to a contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_notes_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier of a contact. (required)
        :param IntercomVersion intercom_version:
        :param int page: The page of results to fetch. Defaults to first page
        :param int per_page: How many results to display per page. Defaults to 15
        :return: NoteList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'intercom_version', 'page', 'per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_notes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `list_notes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/notes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NoteList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_segments_for_a_contact(self, contact_id, **kwargs):  # noqa: E501
        """List attached segments for contact  # noqa: E501

        You can fetch a list of segments that are associated to a contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_segments_for_a_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: ContactSegments
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_segments_for_a_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_segments_for_a_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def list_segments_for_a_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """List attached segments for contact  # noqa: E501

        You can fetch a list of segments that are associated to a contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_segments_for_a_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: ContactSegments
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_segments_for_a_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `list_segments_for_a_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/segments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContactSegments',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_subscriptions_for_a_contact(self, contact_id, **kwargs):  # noqa: E501
        """List subscriptions for a contact  # noqa: E501

        You can fetch a list of subscription types that are attached to a contact. These can be subscriptions that a user has 'opted-in' to or has 'opted-out' from, depending on the subscription type. This will return a list of Subscription Type objects that the contact is associated with.  The data property will show a combined list of:    1.Opt-out subscription types that the user has opted-out from.   2.Opt-in subscription types that the user has opted-in to receiving.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_subscriptions_for_a_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: SubscriptionTypeList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_subscriptions_for_a_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_subscriptions_for_a_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def list_subscriptions_for_a_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """List subscriptions for a contact  # noqa: E501

        You can fetch a list of subscription types that are attached to a contact. These can be subscriptions that a user has 'opted-in' to or has 'opted-out' from, depending on the subscription type. This will return a list of Subscription Type objects that the contact is associated with.  The data property will show a combined list of:    1.Opt-out subscription types that the user has opted-out from.   2.Opt-in subscription types that the user has opted-in to receiving.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_subscriptions_for_a_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: SubscriptionTypeList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_subscriptions_for_a_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `list_subscriptions_for_a_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/subscriptions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='SubscriptionTypeList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def list_tags_for_a_contact(self, contact_id, **kwargs):  # noqa: E501
        """List tags attached to a contact  # noqa: E501

        You can fetch a list of all tags that are attached to a specific contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_tags_for_a_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: TagList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.list_tags_for_a_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.list_tags_for_a_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def list_tags_for_a_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """List tags attached to a contact  # noqa: E501

        You can fetch a list of all tags that are attached to a specific contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.list_tags_for_a_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: The unique identifier for the contact which is given by Intercom (required)
        :param IntercomVersion intercom_version:
        :return: TagList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_tags_for_a_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `list_tags_for_a_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='TagList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def merge_contact(self, **kwargs):  # noqa: E501
        """Merge a lead and a user  # noqa: E501

        You can merge a contact with a `role` of `lead` into a contact with a `role` of `user`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.merge_contact(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MergeContactsRequest body:
        :param IntercomVersion intercom_version:
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.merge_contact_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.merge_contact_with_http_info(**kwargs)  # noqa: E501
            return data

    def merge_contact_with_http_info(self, **kwargs):  # noqa: E501
        """Merge a lead and a user  # noqa: E501

        You can merge a contact with a `role` of `lead` into a contact with a `role` of `user`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.merge_contact_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param MergeContactsRequest body:
        :param IntercomVersion intercom_version:
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method merge_contact" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/merge', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_contacts(self, **kwargs):  # noqa: E501
        """Search contacts  # noqa: E501

        You can search for multiple contacts by the value of their attributes in order to fetch exactly who you want.  To search for contacts, you need to send a `POST` request to `https://api.intercom.io/contacts/search`.  This will accept a query object in the body which will define your filters in order to search for contacts.  {% admonition type=\"warning\" name=\"Optimizing search queries\" %}   Search queries can be complex, so optimizing them can help the performance of your search.   Use the `AND` and `OR` operators to combine multiple filters to get the exact results you need and utilize   pagination to limit the number of results returned. The default is `50` results per page.   See the [pagination section](https://developers.intercom.com/docs/build-an-integration/learn-more/rest-apis/pagination/#example-search-conversations-request) for more details on how to use the `starting_after` param. {% /admonition %} ### Contact Creation Delay  If a contact has recently been created, there is a possibility that it will not yet be available when searching. This means that it may not appear in the response. This delay can take a few minutes. If you need to be instantly notified it is recommended to use webhooks and iterate to see if they match your search filters.  ### Nesting & Limitations  You can nest these filters in order to get even more granular insights that pinpoint exactly what you need. Example: (1 OR 2) AND (3 OR 4). There are some limitations to the amount of multiple's there can be: * There's a limit of max 2 nested filters * There's a limit of max 15 filters for each AND or OR group  ### Searching for Timestamp Fields  All timestamp fields (created_at, updated_at etc.) are indexed as Dates for Contact Search queries; Datetime queries are not currently supported. This means you can only query for timestamp fields by day - not hour, minute or second. For example, if you search for all Contacts with a created_at value greater (>) than 1577869200 (the UNIX timestamp for January 1st, 2020 9:00 AM), that will be interpreted as 1577836800 (January 1st, 2020 12:00 AM). The search results will then include Contacts created from January 2nd, 2020 12:00 AM onwards. If you'd like to get contacts created on January 1st, 2020 you should search with a created_at value equal (=) to 1577836800 (January 1st, 2020 12:00 AM). This behaviour applies only to timestamps used in search queries. The search results will still contain the full UNIX timestamp and be sorted accordingly.  ### Accepted Fields  Most key listed as part of the Contacts Model are searchable, whether writeable or not. The value you search for has to match the accepted type, otherwise the query will fail (ie. as `created_at` accepts a date, the `value` cannot be a string such as `\"foorbar\"`).  | Field                              | Type                           | | ---------------------------------- | ------------------------------ | | id                                 | String                         | | role                               | String<br>Accepts user or lead | | name                               | String                         | | avatar                             | String                         | | owner_id                           | Integer                        | | email                              | String                         | | email_domain                       | String                         | | phone                              | String                         | | formatted_phone                    | String                         | | external_id                        | String                         | | created_at                         | Date (UNIX Timestamp)          | | signed_up_at                       | Date (UNIX Timestamp)          | | updated_at                         | Date (UNIX Timestamp)          | | last_seen_at                       | Date (UNIX Timestamp)          | | last_contacted_at                  | Date (UNIX Timestamp)          | | last_replied_at                    | Date (UNIX Timestamp)          | | last_email_opened_at               | Date (UNIX Timestamp)          | | last_email_clicked_at              | Date (UNIX Timestamp)          | | language_override                  | String                         | | browser                            | String                         | | browser_language                   | String                         | | os                                 | String                         | | location.country                   | String                         | | location.region                    | String                         | | location.city                      | String                         | | unsubscribed_from_emails           | Boolean                        | | marked_email_as_spam               | Boolean                        | | has_hard_bounced                   | Boolean                        | | ios_last_seen_at                   | Date (UNIX Timestamp)          | | ios_app_version                    | String                         | | ios_device                         | String                         | | ios_app_device                     | String                         | | ios_os_version                     | String                         | | ios_app_name                       | String                         | | ios_sdk_version                    | String                         | | android_last_seen_at               | Date (UNIX Timestamp)          | | android_app_version                | String                         | | android_device                     | String                         | | android_app_name                   | String                         | | andoid_sdk_version                 | String                         | | segment_id                         | String                         | | tag_id                             | String                         | | custom_attributes.{attribute_name} | String                         |  ### Accepted Operators  {% admonition type=\"attention\" name=\"Searching based on `created_at`\" %}   You cannot use the `<=` or `>=` operators to search by `created_at`. {% /admonition %}  The table below shows the operators you can use to define how you want to search for the value.  The operator should be put in as a string (`\"=\"`). The operator has to be compatible with the field's type (eg. you cannot search with `>` for a given string value as it's only compatible for integer's and dates).  | Operator | Valid Types                      | Description                                                      | | :------- | :------------------------------- | :--------------------------------------------------------------- | | =        | All                              | Equals                                                           | | !=       | All                              | Doesn't Equal                                                    | | IN       | All                              | In<br>Shortcut for `OR` queries<br>Values must be in Array       | | NIN      | All                              | Not In<br>Shortcut for `OR !` queries<br>Values must be in Array | | >        | Integer<br>Date (UNIX Timestamp) | Greater than                                                     | | <       | Integer<br>Date (UNIX Timestamp) | Lower than                                                       | | ~        | String                           | Contains                                                         | | !~       | String                           | Doesn't Contain                                                  | | ^        | String                           | Starts With                                                      | | $        | String                           | Ends With                                                        |   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_contacts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SearchRequest body:
        :param IntercomVersion intercom_version:
        :return: ContactList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_contacts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_contacts_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_contacts_with_http_info(self, **kwargs):  # noqa: E501
        """Search contacts  # noqa: E501

        You can search for multiple contacts by the value of their attributes in order to fetch exactly who you want.  To search for contacts, you need to send a `POST` request to `https://api.intercom.io/contacts/search`.  This will accept a query object in the body which will define your filters in order to search for contacts.  {% admonition type=\"warning\" name=\"Optimizing search queries\" %}   Search queries can be complex, so optimizing them can help the performance of your search.   Use the `AND` and `OR` operators to combine multiple filters to get the exact results you need and utilize   pagination to limit the number of results returned. The default is `50` results per page.   See the [pagination section](https://developers.intercom.com/docs/build-an-integration/learn-more/rest-apis/pagination/#example-search-conversations-request) for more details on how to use the `starting_after` param. {% /admonition %} ### Contact Creation Delay  If a contact has recently been created, there is a possibility that it will not yet be available when searching. This means that it may not appear in the response. This delay can take a few minutes. If you need to be instantly notified it is recommended to use webhooks and iterate to see if they match your search filters.  ### Nesting & Limitations  You can nest these filters in order to get even more granular insights that pinpoint exactly what you need. Example: (1 OR 2) AND (3 OR 4). There are some limitations to the amount of multiple's there can be: * There's a limit of max 2 nested filters * There's a limit of max 15 filters for each AND or OR group  ### Searching for Timestamp Fields  All timestamp fields (created_at, updated_at etc.) are indexed as Dates for Contact Search queries; Datetime queries are not currently supported. This means you can only query for timestamp fields by day - not hour, minute or second. For example, if you search for all Contacts with a created_at value greater (>) than 1577869200 (the UNIX timestamp for January 1st, 2020 9:00 AM), that will be interpreted as 1577836800 (January 1st, 2020 12:00 AM). The search results will then include Contacts created from January 2nd, 2020 12:00 AM onwards. If you'd like to get contacts created on January 1st, 2020 you should search with a created_at value equal (=) to 1577836800 (January 1st, 2020 12:00 AM). This behaviour applies only to timestamps used in search queries. The search results will still contain the full UNIX timestamp and be sorted accordingly.  ### Accepted Fields  Most key listed as part of the Contacts Model are searchable, whether writeable or not. The value you search for has to match the accepted type, otherwise the query will fail (ie. as `created_at` accepts a date, the `value` cannot be a string such as `\"foorbar\"`).  | Field                              | Type                           | | ---------------------------------- | ------------------------------ | | id                                 | String                         | | role                               | String<br>Accepts user or lead | | name                               | String                         | | avatar                             | String                         | | owner_id                           | Integer                        | | email                              | String                         | | email_domain                       | String                         | | phone                              | String                         | | formatted_phone                    | String                         | | external_id                        | String                         | | created_at                         | Date (UNIX Timestamp)          | | signed_up_at                       | Date (UNIX Timestamp)          | | updated_at                         | Date (UNIX Timestamp)          | | last_seen_at                       | Date (UNIX Timestamp)          | | last_contacted_at                  | Date (UNIX Timestamp)          | | last_replied_at                    | Date (UNIX Timestamp)          | | last_email_opened_at               | Date (UNIX Timestamp)          | | last_email_clicked_at              | Date (UNIX Timestamp)          | | language_override                  | String                         | | browser                            | String                         | | browser_language                   | String                         | | os                                 | String                         | | location.country                   | String                         | | location.region                    | String                         | | location.city                      | String                         | | unsubscribed_from_emails           | Boolean                        | | marked_email_as_spam               | Boolean                        | | has_hard_bounced                   | Boolean                        | | ios_last_seen_at                   | Date (UNIX Timestamp)          | | ios_app_version                    | String                         | | ios_device                         | String                         | | ios_app_device                     | String                         | | ios_os_version                     | String                         | | ios_app_name                       | String                         | | ios_sdk_version                    | String                         | | android_last_seen_at               | Date (UNIX Timestamp)          | | android_app_version                | String                         | | android_device                     | String                         | | android_app_name                   | String                         | | andoid_sdk_version                 | String                         | | segment_id                         | String                         | | tag_id                             | String                         | | custom_attributes.{attribute_name} | String                         |  ### Accepted Operators  {% admonition type=\"attention\" name=\"Searching based on `created_at`\" %}   You cannot use the `<=` or `>=` operators to search by `created_at`. {% /admonition %}  The table below shows the operators you can use to define how you want to search for the value.  The operator should be put in as a string (`\"=\"`). The operator has to be compatible with the field's type (eg. you cannot search with `>` for a given string value as it's only compatible for integer's and dates).  | Operator | Valid Types                      | Description                                                      | | :------- | :------------------------------- | :--------------------------------------------------------------- | | =        | All                              | Equals                                                           | | !=       | All                              | Doesn't Equal                                                    | | IN       | All                              | In<br>Shortcut for `OR` queries<br>Values must be in Array       | | NIN      | All                              | Not In<br>Shortcut for `OR !` queries<br>Values must be in Array | | >        | Integer<br>Date (UNIX Timestamp) | Greater than                                                     | | <       | Integer<br>Date (UNIX Timestamp) | Lower than                                                       | | ~        | String                           | Contains                                                         | | !~       | String                           | Doesn't Contain                                                  | | ^        | String                           | Starts With                                                      | | $        | String                           | Ends With                                                        |   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_contacts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param SearchRequest body:
        :param IntercomVersion intercom_version:
        :return: ContactList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_contacts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContactList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def show_contact(self, contact_id, **kwargs):  # noqa: E501
        """Get a contact  # noqa: E501

        You can fetch the details of a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: id (required)
        :param IntercomVersion intercom_version:
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.show_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.show_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def show_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Get a contact  # noqa: E501

        You can fetch the details of a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.show_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: id (required)
        :param IntercomVersion intercom_version:
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method show_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `show_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def unarchive_contact(self, contact_id, **kwargs):  # noqa: E501
        """Unarchive contact  # noqa: E501

        You can unarchive a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unarchive_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: id (required)
        :param IntercomVersion intercom_version:
        :return: ContactUnarchived
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.unarchive_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.unarchive_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def unarchive_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Unarchive contact  # noqa: E501

        You can unarchive a single contact.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.unarchive_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: id (required)
        :param IntercomVersion intercom_version:
        :return: ContactUnarchived
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unarchive_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `unarchive_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}/unarchive', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ContactUnarchived',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_contact(self, contact_id, **kwargs):  # noqa: E501
        """Update a contact  # noqa: E501

        You can update an existing contact (ie. user or lead).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_contact(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: id (required)
        :param UpdateContactRequest body:
        :param IntercomVersion intercom_version:
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
        else:
            (data) = self.update_contact_with_http_info(contact_id, **kwargs)  # noqa: E501
            return data

    def update_contact_with_http_info(self, contact_id, **kwargs):  # noqa: E501
        """Update a contact  # noqa: E501

        You can update an existing contact (ie. user or lead).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_contact_with_http_info(contact_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str contact_id: id (required)
        :param UpdateContactRequest body:
        :param IntercomVersion intercom_version:
        :return: Contact
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['contact_id', 'body', 'intercom_version']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_contact" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'contact_id' is set
        if ('contact_id' not in params or
                params['contact_id'] is None):
            raise ValueError("Missing the required parameter `contact_id` when calling `update_contact`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'contact_id' in params:
            path_params['contact_id'] = params['contact_id']  # noqa: E501

        query_params = []

        header_params = {}
        if 'intercom_version' in params:
            header_params['Intercom-Version'] = params['intercom_version']  # noqa: E501

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['bearerAuth']  # noqa: E501

        return self.api_client.call_api(
            '/contacts/{contact_id}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Contact',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
